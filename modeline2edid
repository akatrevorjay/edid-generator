#!/bin/zsh
emulate -L zsh

setopt errexit errreturn
#setopt xtrace

template-S() {
	[[ ${(L)1} = mode(|line) ]] || return 1
	echo "-- Found naughty unicorn: $@"
	shift 1

	local name="${1//\"}"
	[[ -z "$name" ]] && echo "Could not parse modeline: $@" >&2 && return 1
	local fn="${name}.S"

	local -F pixel_clock_mhz=$2
	local -i pixel_clock_khz=$((pixel_clock_mhz * 1000))
	shift 2

	local -i hdisp="$1" hsyncstart="$2" hsyncend="$3" htotal="$4"; shift 4
	local -i vdisp="$1" vsyncstart="$2" vsyncend="$3" vtotal="$4"; shift 4

	local -i hsync_polarity=0 vsync_polarity=0 dpi=96 vfreq_hz=60
	local edid_version="1.3" ratio="compute"  # TODO calc ratio

	local arg
	for arg in "$@"; do
		case "${(L)arg}" in
			[-+]hsync) [[ "${arg:1:1}" == "-" ]] || hsync_polarity=1 ;;
			[-+]vsync) [[ "${arg:1:1}" == "-" ]] || vsync_polarity=1 ;;
			ratio=*|xy_ratio=*) ratio="${arg#*=}" ;;
			dpi=*) dpi="${arg#*=}" ;;
			edid_version=*) edid_version="${arg#*=}" ;;
			vfreq=*|vfreq_hz=*) vfreq_hz="${arg#*=}" ;;
			*) echo "Ignoring unknown modeline option passed: '$arg'" >&2 ;;
		esac
	done

    case "$ratio" in
        compute)
            find-closest-ratio() {
                local x=$1 y=$2 default=$3; shift 3
                [ $# -gt 0 ] || set -- 16:10 16:9 4:3 5:4  # supported already in edid.S

                local -A vals=()
                local r
                for r in "$@"; do
                    local -i rx=${ratio%%:*} ry=${ratio#*:}
                    local v=$(( abs( $x / $rx - $y / $ry ) ))
                    vals[$v]=$
                done
                echo $(( $hdisp / 16 ))
            }
            ratio="16:9"
            if [[ $(( $hdisp / 16 - $vdisp / 9 )) -lt $(( h )) ]]; then
            local -a vals=($(( $hdisp / 4 - $vdisp / 3 )))
            for 
            if [[ $(()) ]]
            ;;
    esac

    esac
	local -A defines
	defines=(
		VERSION "${edid_version%%.*}"
		REVISION "${edid_version#*.}"
		CLOCK   "$pixel_clock_khz"
		XPIX    "$hdisp"
		YPIX    "$vdisp"
		XY_RATIO "XY_RATIO_${(U)ratio//:/_}"
		XBLANK  "$((htotal - hdisp))"
		YBLANK  "$((vtotal - vdisp))"
		XOFFSET "$((hsyncstart - hdisp))"
		XPULSE  "$((hsyncend - hsyncstart))"
		YOFFSET "(63+$((vsyncstart - vdisp)))"
		YPULSE  "(63+$((vsyncend - vsyncstart)))"
		DPI "$dpi"
		VFREQ "$vfreq_hz"
                TIMING_NAME "${(qqq)name}"
		HSYNC_POL "$hsync_polarity"
		VSYNC_POL "$vsync_polarity"
	)

        local lines=('/* '"$name: $REPLY"' */') # removed -a option
	local k
	for k in "${(@k)defines}"; do
		lines+=("#define $k ${defines[$k]}")

	done
	lines+=('#include "edid.S"')

	echo "${(j:\n:)lines[@]}" > "$fn"
	echo "Wrote $fn"
}

local f=${1:-'-'}
[[ $f != '-' ]] || f="/dev/stdin"

if [[ -z "$f" || "$f" == "-h" ]]; then
	self=${0:t}
	cat >&2 <<-EOF
	Modeline2EDID, version forever 0.0.1
	Help:
	  $self -h
	Parse modelines from stdin:
	  $self
	  $self -
	Parse modelines from a file (eg xorg.conf)
	  $self FILENAME
	EOF
	exit 1
fi

echo "Searching for runaway unicorns in '$f'"
while read; do
	# trim
	REPLY=($=REPLY)
	[[ -n "$REPLY" ]] || continue
	template-S ${(@)REPLY} || :
done < $f
